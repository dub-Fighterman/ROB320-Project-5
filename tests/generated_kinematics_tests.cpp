// AUTO-GENERATED FILE - DO NOT EDIT
// Generated by generate_test_cases.cpp

#include <gtest/gtest.h>

#include "rix/robot/kinematics_solver.hpp"
#include "rix/robot/robot_model.hpp"
#include "robots.hpp"

using rix::msg::geometry::Transform;
using rix::msg::sensor::JS;
using namespace rix::robot;

TEST(KinematicsSolver, FK_HardCoded_SIMPLEBOT_Test1) {
    auto robot = std::make_shared<RobotModel>(RobotModel::from_json(SIMPLEBOT_JRDF));
    KinematicsSolver solver(robot);

    JS state;
    state.joint_states.resize(4);
    state.joint_states[0].name = "waist";
    state.joint_states[0].position = 0;
    state.joint_states[0].velocity = 0.000000;
    state.joint_states[0].effort = 0.000000;
    state.joint_states[1].name = "shoulder";
    state.joint_states[1].position = 0;
    state.joint_states[1].velocity = 0.000000;
    state.joint_states[1].effort = 0.000000;
    state.joint_states[2].name = "elbow";
    state.joint_states[2].position = 0;
    state.joint_states[2].velocity = 0.000000;
    state.joint_states[2].effort = 0.000000;
    state.joint_states[3].name = "wrist";
    state.joint_states[3].position = 0;
    state.joint_states[3].velocity = 0.000000;
    state.joint_states[3].effort = 0.000000;
    robot->set_state(state);

    Transform result = solver.solve_fk("tool");
    Eigen::Affine3d actual = msg_to_eigen(result);

    Eigen::Affine3d expected;
    expected.matrix() << 1, 0, 0, 0.337500005960464, 0, 1, 0, 0, 0, 0, 1, 0.300000011920929, 0, 0, 0, 1;

    EXPECT_TRUE(actual.matrix().isApprox(expected.matrix(), 1e-10)) << "FK output doesn't match expected transform\n"
                                                                    << "Actual:\n"
                                                                    << actual.matrix() << "\n"
                                                                    << "Expected:\n"
                                                                    << expected.matrix() << "\n"
                                                                    << "Difference:\n"
                                                                    << (actual.matrix() - expected.matrix());
}

TEST(KinematicsSolver, FK_HardCoded_SIMPLEBOT_Test2) {
    auto robot = std::make_shared<RobotModel>(RobotModel::from_json(SIMPLEBOT_JRDF));
    KinematicsSolver solver(robot);

    JS state;
    state.joint_states.resize(4);
    state.joint_states[0].name = "waist";
    state.joint_states[0].position = 0.1;
    state.joint_states[0].velocity = 0.000000;
    state.joint_states[0].effort = 0.000000;
    state.joint_states[1].name = "shoulder";
    state.joint_states[1].position = 0.2;
    state.joint_states[1].velocity = 0.000000;
    state.joint_states[1].effort = 0.000000;
    state.joint_states[2].name = "elbow";
    state.joint_states[2].position = -0.3;
    state.joint_states[2].velocity = 0.000000;
    state.joint_states[2].effort = 0.000000;
    state.joint_states[3].name = "wrist";
    state.joint_states[3].position = 0.01;
    state.joint_states[3].velocity = 0.000000;
    state.joint_states[3].effort = 0.000000;
    robot->set_state(state);

    Transform result = solver.solve_fk("tool");
    Eigen::Affine3d actual = msg_to_eigen(result);

    Eigen::Affine3d expected;
    expected.matrix() << 0.990033289457381, -0.0998334145396565, -0.0993346633211549, 0.330351710319519,
        0.0993346633211549, 0.995004165547275, -0.00996671066699983, 0.043195940554142, 0.0998334145396565,
        1.2438072793941e-10, 0.995004165547275, 0.270249485969543, 0, 0, 0, 1;

    EXPECT_TRUE(actual.matrix().isApprox(expected.matrix(), 1e-10)) << "FK output doesn't match expected transform\n"
                                                                    << "Actual:\n"
                                                                    << actual.matrix() << "\n"
                                                                    << "Expected:\n"
                                                                    << expected.matrix() << "\n"
                                                                    << "Difference:\n"
                                                                    << (actual.matrix() - expected.matrix());
}

TEST(KinematicsSolver, Jacobian_HardCoded_SIMPLEBOT_Test1) {
    auto robot = std::make_shared<RobotModel>(RobotModel::from_json(SIMPLEBOT_JRDF));
    KinematicsSolver solver(robot);

    JS state;
    state.joint_states.resize(4);
    state.joint_states[0].name = "waist";
    state.joint_states[0].position = 0;
    state.joint_states[0].velocity = 0.000000;
    state.joint_states[0].effort = 0.000000;
    state.joint_states[1].name = "shoulder";
    state.joint_states[1].position = 0;
    state.joint_states[1].velocity = 0.000000;
    state.joint_states[1].effort = 0.000000;
    state.joint_states[2].name = "elbow";
    state.joint_states[2].position = 0;
    state.joint_states[2].velocity = 0.000000;
    state.joint_states[2].effort = 0.000000;
    state.joint_states[3].name = "wrist";
    state.joint_states[3].position = 0;
    state.joint_states[3].velocity = 0.000000;
    state.joint_states[3].effort = 0.000000;
    robot->set_state(state);

    auto chain = robot->get_joints_in_chain("tool");
    Eigen::Affine3d ee_transform;
    Eigen::MatrixXd actual = solver.get_jacobian(chain, ee_transform);

    Eigen::MatrixXd expected = (Eigen::MatrixXd(6, 4) << 0, 0, 0, 0, 0.337500005960464, 0, 0, 1, 0, -0.300000004470348,
                                -0.100000001490116, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0)
                                   .finished();

    EXPECT_TRUE(actual.isApprox(expected, 1e-10)) << "Jacobian doesn't match expected\n"
                                                  << "Actual:\n"
                                                  << actual << "\n"
                                                  << "Expected:\n"
                                                  << expected << "\n"
                                                  << "Difference:\n"
                                                  << (actual - expected);
}

TEST(KinematicsSolver, Jacobian_HardCoded_SIMPLEBOT_Test2) {
    auto robot = std::make_shared<RobotModel>(RobotModel::from_json(SIMPLEBOT_JRDF));
    KinematicsSolver solver(robot);

    JS state;
    state.joint_states.resize(4);
    state.joint_states[0].name = "waist";
    state.joint_states[0].position = 0.1;
    state.joint_states[0].velocity = 0.000000;
    state.joint_states[0].effort = 0.000000;
    state.joint_states[1].name = "shoulder";
    state.joint_states[1].position = 0.2;
    state.joint_states[1].velocity = 0.000000;
    state.joint_states[1].effort = 0.000000;
    state.joint_states[2].name = "elbow";
    state.joint_states[2].position = -0.3;
    state.joint_states[2].velocity = 0.000000;
    state.joint_states[2].effort = 0.000000;
    state.joint_states[3].name = "wrist";
    state.joint_states[3].position = 0.01;
    state.joint_states[3].velocity = 0.000000;
    state.joint_states[3].effort = 0.000000;
    robot->set_state(state);

    auto chain = robot->get_joints_in_chain("tool");
    Eigen::Affine3d ee_transform;
    Eigen::MatrixXd actual = solver.get_jacobian(chain, ee_transform);

    Eigen::MatrixXd expected = (Eigen::MatrixXd(6, 4) << -0.0431959407864793, -0.0296018961759212, 0.00993346615167093,
                                -0.099833416851189, 0.330351722605513, -0.0029700965517902, 0.000996671070970147,
                                0.995004165347791, 0, -0.295513736888266, -0.0995004181492769, 0, 0, -0.099833416851189,
                                -0.099833416851189, 0, 0, 0.995004165347791, 0.995004165347791, 0, 1, 0, 0, 0)
                                   .finished();

    EXPECT_TRUE(actual.isApprox(expected, 1e-10)) << "Jacobian doesn't match expected\n"
                                                  << "Actual:\n"
                                                  << actual << "\n"
                                                  << "Expected:\n"
                                                  << expected << "\n"
                                                  << "Difference:\n"
                                                  << (actual - expected);
}

TEST(KinematicsSolver, IK_HardCoded_SIMPLEBOT_Test1) {
    auto robot = std::make_shared<RobotModel>(RobotModel::from_json(SIMPLEBOT_JRDF));
    KinematicsSolver solver(robot);

    Transform goal = eigen_to_msg(
        Eigen::Affine3d((Eigen::Matrix4d() << 1, 0, 0, 0.3375, 0, 1, 0, 0, 0, 0, 1, 0.3, 0, 0, 0, 1).finished()));

    JS state;
    state.joint_states.resize(4);
    state.joint_states[0].name = "waist";
    state.joint_states[0].position = 0.1;
    state.joint_states[0].velocity = 0.000000;
    state.joint_states[0].effort = 0.000000;
    state.joint_states[1].name = "shoulder";
    state.joint_states[1].position = 0.1;
    state.joint_states[1].velocity = 0.000000;
    state.joint_states[1].effort = 0.000000;
    state.joint_states[2].name = "elbow";
    state.joint_states[2].position = 0.1;
    state.joint_states[2].velocity = 0.000000;
    state.joint_states[2].effort = 0.000000;
    state.joint_states[3].name = "wrist";
    state.joint_states[3].position = 0.1;
    state.joint_states[3].velocity = 0.000000;
    state.joint_states[3].effort = 0.000000;

    JS solution;
    bool converged = solver.solve_ik("tool", goal, state, solution);

    EXPECT_TRUE(converged) << "IK should converge for this test case";

    if (converged) {
        robot->set_state(solution);
        Transform result = solver.solve_fk("tool");
        Eigen::Affine3d result_transform = msg_to_eigen(result);
        Eigen::Affine3d goal_transform = msg_to_eigen(goal);

        Eigen::Vector3d pos_error = result_transform.translation() - goal_transform.translation();
        EXPECT_LT(pos_error.norm(), 1e-3) << "Position error too large";

        Eigen::AngleAxisd rot_error(goal_transform.rotation() * result_transform.rotation().transpose());
        EXPECT_LT(std::abs(rot_error.angle()), 1e-3) << "Orientation error too large";
    }
}

TEST(KinematicsSolver, IK_HardCoded_SIMPLEBOT_Test2) {
    auto robot = std::make_shared<RobotModel>(RobotModel::from_json(SIMPLEBOT_JRDF));
    KinematicsSolver solver(robot);

    Transform goal = eigen_to_msg(
        Eigen::Affine3d((Eigen::Matrix4d() << 0.990033, -0.0998334, -0.0993347, 0.330352, 0.0993347, 0.995004,
                         -0.00996671, 0.0431959, 0.0998334, 1.24381e-10, 0.995004, 0.270249, 0, 0, 0, 1)
                            .finished()));

    JS state;
    state.joint_states.resize(4);
    state.joint_states[0].name = "waist";
    state.joint_states[0].position = 0.1;
    state.joint_states[0].velocity = 0.000000;
    state.joint_states[0].effort = 0.000000;
    state.joint_states[1].name = "shoulder";
    state.joint_states[1].position = 0.1;
    state.joint_states[1].velocity = 0.000000;
    state.joint_states[1].effort = 0.000000;
    state.joint_states[2].name = "elbow";
    state.joint_states[2].position = 0.1;
    state.joint_states[2].velocity = 0.000000;
    state.joint_states[2].effort = 0.000000;
    state.joint_states[3].name = "wrist";
    state.joint_states[3].position = 0.1;
    state.joint_states[3].velocity = 0.000000;
    state.joint_states[3].effort = 0.000000;

    JS solution;
    bool converged = solver.solve_ik("tool", goal, state, solution);

    EXPECT_TRUE(converged) << "IK should converge for this test case";

    if (converged) {
        robot->set_state(solution);
        Transform result = solver.solve_fk("tool");
        Eigen::Affine3d result_transform = msg_to_eigen(result);
        Eigen::Affine3d goal_transform = msg_to_eigen(goal);

        Eigen::Vector3d pos_error = result_transform.translation() - goal_transform.translation();
        EXPECT_LT(pos_error.norm(), 1e-3) << "Position error too large";

        Eigen::AngleAxisd rot_error(goal_transform.rotation() * result_transform.rotation().transpose());
        EXPECT_LT(std::abs(rot_error.angle()), 1e-3) << "Orientation error too large";
    }
}

TEST(KinematicsSolver, FK_HardCoded_RX200_Test1) {
    auto robot = std::make_shared<RobotModel>(RobotModel::from_json(RX200_JRDF));
    KinematicsSolver solver(robot);

    JS state;
    state.joint_states.resize(5);
    state.joint_states[0].name = "waist";
    state.joint_states[0].position = 0;
    state.joint_states[0].velocity = 0.000000;
    state.joint_states[0].effort = 0.000000;
    state.joint_states[1].name = "shoulder";
    state.joint_states[1].position = 0;
    state.joint_states[1].velocity = 0.000000;
    state.joint_states[1].effort = 0.000000;
    state.joint_states[2].name = "elbow";
    state.joint_states[2].position = 0;
    state.joint_states[2].velocity = 0.000000;
    state.joint_states[2].effort = 0.000000;
    state.joint_states[3].name = "wrist_angle";
    state.joint_states[3].position = 0;
    state.joint_states[3].velocity = 0.000000;
    state.joint_states[3].effort = 0.000000;
    state.joint_states[4].name = "wrist_rotate";
    state.joint_states[4].position = 0;
    state.joint_states[4].velocity = 0.000000;
    state.joint_states[4].effort = 0.000000;
    robot->set_state(state);

    Transform result = solver.solve_fk("/gripper_link");
    Eigen::Affine3d actual = msg_to_eigen(result);

    Eigen::Affine3d expected;
    expected.matrix() << -1, -1.22464685258517e-16, 0, -0.314999997615814, 1.22464685258517e-16, -1, 0,
        3.85763751946883e-17, 0, 0, 1, 0.30391001701355, 0, 0, 0, 1;

    EXPECT_TRUE(actual.matrix().isApprox(expected.matrix(), 1e-10)) << "FK output doesn't match expected transform\n"
                                                                    << "Actual:\n"
                                                                    << actual.matrix() << "\n"
                                                                    << "Expected:\n"
                                                                    << expected.matrix() << "\n"
                                                                    << "Difference:\n"
                                                                    << (actual.matrix() - expected.matrix());
}

TEST(KinematicsSolver, Jacobian_HardCoded_RX200_Test1) {
    auto robot = std::make_shared<RobotModel>(RobotModel::from_json(RX200_JRDF));
    KinematicsSolver solver(robot);

    JS state;
    state.joint_states.resize(5);
    state.joint_states[0].name = "waist";
    state.joint_states[0].position = 0;
    state.joint_states[0].velocity = 0.000000;
    state.joint_states[0].effort = 0.000000;
    state.joint_states[1].name = "shoulder";
    state.joint_states[1].position = 0;
    state.joint_states[1].velocity = 0.000000;
    state.joint_states[1].effort = 0.000000;
    state.joint_states[2].name = "elbow";
    state.joint_states[2].position = 0;
    state.joint_states[2].velocity = 0.000000;
    state.joint_states[2].effort = 0.000000;
    state.joint_states[3].name = "wrist_angle";
    state.joint_states[3].position = 0;
    state.joint_states[3].velocity = 0.000000;
    state.joint_states[3].effort = 0.000000;
    state.joint_states[4].name = "wrist_rotate";
    state.joint_states[4].position = 0;
    state.joint_states[4].velocity = 0.000000;
    state.joint_states[4].effort = 0.000000;
    robot->set_state(state);

    auto chain = robot->get_joints_in_chain("/gripper_link");
    Eigen::Affine3d ee_transform;
    Eigen::MatrixXd actual = solver.get_jacobian(chain, ee_transform);

    Eigen::MatrixXd expected =
        (Eigen::MatrixXd(6, 5) << -3.85763760206707e-17, 0.200000002980232, -3.97436377983817e-33, -9.7484390804833e-34,
         0, -0.315000001341105, -2.44929374166766e-17, -3.24531416665016e-17, -7.96020424982503e-18, 0, 0,
         0.315000001341105, 0.265000000596046, 0.0649999976158142, -0, 0, 1.22464685258517e-16, 1.22464685258517e-16,
         1.22464685258517e-16, -1, 0, 1, 1, 1, 1.22464685258517e-16, 1, 0, 1.22464685258517e-16, 1.22464685258517e-16,
         0)
            .finished();

    EXPECT_TRUE(actual.isApprox(expected, 1e-10)) << "Jacobian doesn't match expected\n"
                                                  << "Actual:\n"
                                                  << actual << "\n"
                                                  << "Expected:\n"
                                                  << expected << "\n"
                                                  << "Difference:\n"
                                                  << (actual - expected);
}

TEST(KinematicsSolver, FK_HardCoded_RX200_Test2) {
    auto robot = std::make_shared<RobotModel>(RobotModel::from_json(RX200_JRDF));
    KinematicsSolver solver(robot);

    JS state;
    state.joint_states.resize(5);
    state.joint_states[0].name = "waist";
    state.joint_states[0].position = 0.5;
    state.joint_states[0].velocity = 0.000000;
    state.joint_states[0].effort = 0.000000;
    state.joint_states[1].name = "shoulder";
    state.joint_states[1].position = -0.5;
    state.joint_states[1].velocity = 0.000000;
    state.joint_states[1].effort = 0.000000;
    state.joint_states[2].name = "elbow";
    state.joint_states[2].position = 0.7;
    state.joint_states[2].velocity = 0.000000;
    state.joint_states[2].effort = 0.000000;
    state.joint_states[3].name = "wrist_angle";
    state.joint_states[3].position = -0.2;
    state.joint_states[3].velocity = 0.000000;
    state.joint_states[3].effort = 0.000000;
    state.joint_states[4].name = "wrist_rotate";
    state.joint_states[4].position = 1;
    state.joint_states[4].velocity = 0.000000;
    state.joint_states[4].effort = 0.000000;
    robot->set_state(state);

    Transform result = solver.solve_fk("/gripper_link");
    Eigen::Affine3d actual = msg_to_eigen(result);

    Eigen::Affine3d expected;
    expected.matrix() << -0.877582679438804, 0.259034714930215, -0.403422716185801, -0.351715385913849,
        -0.479425564059434, -0.474159971250644, 0.73846031128316, -0.192142993211746, -2.2500923790858e-08,
        0.841471044822785, 0.540302264676268, 0.295189082622528, 0, 0, 0, 1;

    EXPECT_TRUE(actual.matrix().isApprox(expected.matrix(), 1e-10)) << "FK output doesn't match expected transform\n"
                                                                    << "Actual:\n"
                                                                    << actual.matrix() << "\n"
                                                                    << "Expected:\n"
                                                                    << expected.matrix() << "\n"
                                                                    << "Difference:\n"
                                                                    << (actual.matrix() - expected.matrix());
}

TEST(KinematicsSolver, Jacobian_HardCoded_RX200_Test2) {
    auto robot = std::make_shared<RobotModel>(RobotModel::from_json(RX200_JRDF));
    KinematicsSolver solver(robot);

    JS state;
    state.joint_states.resize(5);
    state.joint_states[0].name = "waist";
    state.joint_states[0].position = 0.5;
    state.joint_states[0].velocity = 0.000000;
    state.joint_states[0].effort = 0.000000;
    state.joint_states[1].name = "shoulder";
    state.joint_states[1].position = -0.5;
    state.joint_states[1].velocity = 0.000000;
    state.joint_states[1].effort = 0.000000;
    state.joint_states[2].name = "elbow";
    state.joint_states[2].position = 0.7;
    state.joint_states[2].velocity = 0.000000;
    state.joint_states[2].effort = 0.000000;
    state.joint_states[3].name = "wrist_angle";
    state.joint_states[3].position = -0.2;
    state.joint_states[3].velocity = 0.000000;
    state.joint_states[3].effort = 0.000000;
    state.joint_states[4].name = "wrist_rotate";
    state.joint_states[4].position = 1;
    state.joint_states[4].velocity = 0.000000;
    state.joint_states[4].effort = 0.000000;
    robot->set_state(state);

    auto chain = robot->get_joints_in_chain("/gripper_link");
    Eigen::Affine3d ee_transform;
    Eigen::MatrixXd actual = solver.get_jacobian(chain, ee_transform);

    Eigen::MatrixXd expected =
        (Eigen::MatrixXd(6, 5) << 0.192143000419117, 0.167863199870771, 0.0348697440459978, -9.62227620000023e-10, 0,
         -0.351715393380412, 0.0917040865716066, 0.0190494285178984, -5.25667367059783e-10, 0, 0, 0.400777557658921,
         0.261013317777673, 0.064999997856719, 0, 0, -0.479425549044071, -0.479425549044071, -0.479425549044071,
         -0.877582559109447, 0, 0.877582556798039, 0.877582556798039, 0.877582556798039, -0.4794255503068, 1, 0,
         1.07472871606636e-16, 1.07472871606636e-16, -1.68685010959457e-08)
            .finished();

    EXPECT_TRUE(actual.isApprox(expected, 1e-10)) << "Jacobian doesn't match expected\n"
                                                  << "Actual:\n"
                                                  << actual << "\n"
                                                  << "Expected:\n"
                                                  << expected << "\n"
                                                  << "Difference:\n"
                                                  << (actual - expected);
}

TEST(KinematicsSolver, IK_HardCoded_RX200_Test1) {
    auto robot = std::make_shared<RobotModel>(RobotModel::from_json(RX200_JRDF));
    KinematicsSolver solver(robot);

    Transform goal = eigen_to_msg(Eigen::Affine3d((Eigen::Matrix4d() << -1, -1.22465e-16, 0, -0.315, 1.22465e-16, -1, 0,
                                                   3.85764e-17, 0, 0, 1, 0.30391, 0, 0, 0, 1)
                                                      .finished()));

    JS state;
    state.joint_states.resize(5);
    state.joint_states[0].name = "waist";
    state.joint_states[0].position = 0.1;
    state.joint_states[0].velocity = 0.000000;
    state.joint_states[0].effort = 0.000000;
    state.joint_states[1].name = "shoulder";
    state.joint_states[1].position = 0.1;
    state.joint_states[1].velocity = 0.000000;
    state.joint_states[1].effort = 0.000000;
    state.joint_states[2].name = "elbow";
    state.joint_states[2].position = 0.1;
    state.joint_states[2].velocity = 0.000000;
    state.joint_states[2].effort = 0.000000;
    state.joint_states[3].name = "wrist_angle";
    state.joint_states[3].position = 0.1;
    state.joint_states[3].velocity = 0.000000;
    state.joint_states[3].effort = 0.000000;
    state.joint_states[4].name = "wrist_rotate";
    state.joint_states[4].position = 0.1;
    state.joint_states[4].velocity = 0.000000;
    state.joint_states[4].effort = 0.000000;

    JS solution;
    bool converged = solver.solve_ik("/gripper_link", goal, state, solution);

    EXPECT_TRUE(converged) << "IK should converge for this test case";

    if (converged) {
        robot->set_state(solution);
        Transform result = solver.solve_fk("/gripper_link");
        Eigen::Affine3d result_transform = msg_to_eigen(result);
        Eigen::Affine3d goal_transform = msg_to_eigen(goal);

        Eigen::Vector3d pos_error = result_transform.translation() - goal_transform.translation();
        EXPECT_LT(pos_error.norm(), 1e-3) << "Position error too large";

        Eigen::AngleAxisd rot_error(goal_transform.rotation() * result_transform.rotation().transpose());
        EXPECT_LT(std::abs(rot_error.angle()), 1e-3) << "Orientation error too large";
    }
}

TEST(KinematicsSolver, IK_HardCoded_RX200_Test2) {
    auto robot = std::make_shared<RobotModel>(RobotModel::from_json(RX200_JRDF));
    KinematicsSolver solver(robot);

    Transform goal = eigen_to_msg(
        Eigen::Affine3d((Eigen::Matrix4d() << -0.877583, 0.259035, -0.403423, -0.351715, -0.479426, -0.47416, 0.73846,
                         -0.192143, -2.25009e-08, 0.841471, 0.540302, 0.295189, 0, 0, 0, 1)
                            .finished()));

    JS state;
    state.joint_states.resize(5);
    state.joint_states[0].name = "waist";
    state.joint_states[0].position = 0.1;
    state.joint_states[0].velocity = 0.000000;
    state.joint_states[0].effort = 0.000000;
    state.joint_states[1].name = "shoulder";
    state.joint_states[1].position = 0.1;
    state.joint_states[1].velocity = 0.000000;
    state.joint_states[1].effort = 0.000000;
    state.joint_states[2].name = "elbow";
    state.joint_states[2].position = 0.1;
    state.joint_states[2].velocity = 0.000000;
    state.joint_states[2].effort = 0.000000;
    state.joint_states[3].name = "wrist_angle";
    state.joint_states[3].position = 0.1;
    state.joint_states[3].velocity = 0.000000;
    state.joint_states[3].effort = 0.000000;
    state.joint_states[4].name = "wrist_rotate";
    state.joint_states[4].position = 0.1;
    state.joint_states[4].velocity = 0.000000;
    state.joint_states[4].effort = 0.000000;

    JS solution;
    bool converged = solver.solve_ik("/gripper_link", goal, state, solution);

    EXPECT_TRUE(converged) << "IK should converge for this test case";

    if (converged) {
        robot->set_state(solution);
        Transform result = solver.solve_fk("/gripper_link");
        Eigen::Affine3d result_transform = msg_to_eigen(result);
        Eigen::Affine3d goal_transform = msg_to_eigen(goal);

        Eigen::Vector3d pos_error = result_transform.translation() - goal_transform.translation();
        EXPECT_LT(pos_error.norm(), 1e-3) << "Position error too large";

        Eigen::AngleAxisd rot_error(goal_transform.rotation() * result_transform.rotation().transpose());
        EXPECT_LT(std::abs(rot_error.angle()), 1e-3) << "Orientation error too large";
    }
}

TEST(KinematicsSolver, FK_HardCoded_FETCH_Test1) {
    auto robot = std::make_shared<RobotModel>(RobotModel::from_json(FETCH_JRDF));
    KinematicsSolver solver(robot);

    JS state;
    state.joint_states.resize(9);
    state.joint_states[0].name = "torso_lift_joint";
    state.joint_states[0].position = 0;
    state.joint_states[0].velocity = 0.000000;
    state.joint_states[0].effort = 0.000000;
    state.joint_states[1].name = "shoulder_pan_joint";
    state.joint_states[1].position = 0;
    state.joint_states[1].velocity = 0.000000;
    state.joint_states[1].effort = 0.000000;
    state.joint_states[2].name = "shoulder_lift_joint";
    state.joint_states[2].position = 0;
    state.joint_states[2].velocity = 0.000000;
    state.joint_states[2].effort = 0.000000;
    state.joint_states[3].name = "upperarm_roll_joint";
    state.joint_states[3].position = 0;
    state.joint_states[3].velocity = 0.000000;
    state.joint_states[3].effort = 0.000000;
    state.joint_states[4].name = "elbow_flex_joint";
    state.joint_states[4].position = 0;
    state.joint_states[4].velocity = 0.000000;
    state.joint_states[4].effort = 0.000000;
    state.joint_states[5].name = "forearm_roll_joint";
    state.joint_states[5].position = 0;
    state.joint_states[5].velocity = 0.000000;
    state.joint_states[5].effort = 0.000000;
    state.joint_states[6].name = "wrist_flex_joint";
    state.joint_states[6].position = 0;
    state.joint_states[6].velocity = 0.000000;
    state.joint_states[6].effort = 0.000000;
    state.joint_states[7].name = "wrist_roll_joint";
    state.joint_states[7].position = 0;
    state.joint_states[7].velocity = 0.000000;
    state.joint_states[7].effort = 0.000000;
    state.joint_states[8].name = "gripper_axis";
    state.joint_states[8].position = 0;
    state.joint_states[8].velocity = 0.000000;
    state.joint_states[8].effort = 0.000000;
    robot->set_state(state);

    Transform result = solver.solve_fk("gripper_link");
    Eigen::Affine3d actual = msg_to_eigen(result);

    Eigen::Affine3d expected;
    expected.matrix() << 1, -0, 0, 1.12810003757477, 0, 1, 6.12300000537636e-17, 2.50173530164497e-17, -0,
        -6.12300000537636e-17, 1, 0.786009967327118, 0, 0, 0, 1;

    EXPECT_TRUE(actual.matrix().isApprox(expected.matrix(), 1e-10)) << "FK output doesn't match expected transform\n"
                                                                    << "Actual:\n"
                                                                    << actual.matrix() << "\n"
                                                                    << "Expected:\n"
                                                                    << expected.matrix() << "\n"
                                                                    << "Difference:\n"
                                                                    << (actual.matrix() - expected.matrix());
}

TEST(KinematicsSolver, Jacobian_HardCoded_FETCH_Test1) {
    auto robot = std::make_shared<RobotModel>(RobotModel::from_json(FETCH_JRDF));
    KinematicsSolver solver(robot);

    JS state;
    state.joint_states.resize(9);
    state.joint_states[0].name = "torso_lift_joint";
    state.joint_states[0].position = 0;
    state.joint_states[0].velocity = 0.000000;
    state.joint_states[0].effort = 0.000000;
    state.joint_states[1].name = "shoulder_pan_joint";
    state.joint_states[1].position = 0;
    state.joint_states[1].velocity = 0.000000;
    state.joint_states[1].effort = 0.000000;
    state.joint_states[2].name = "shoulder_lift_joint";
    state.joint_states[2].position = 0;
    state.joint_states[2].velocity = 0.000000;
    state.joint_states[2].effort = 0.000000;
    state.joint_states[3].name = "upperarm_roll_joint";
    state.joint_states[3].position = 0;
    state.joint_states[3].velocity = 0.000000;
    state.joint_states[3].effort = 0.000000;
    state.joint_states[4].name = "elbow_flex_joint";
    state.joint_states[4].position = 0;
    state.joint_states[4].velocity = 0.000000;
    state.joint_states[4].effort = 0.000000;
    state.joint_states[5].name = "forearm_roll_joint";
    state.joint_states[5].position = 0;
    state.joint_states[5].velocity = 0.000000;
    state.joint_states[5].effort = 0.000000;
    state.joint_states[6].name = "wrist_flex_joint";
    state.joint_states[6].position = 0;
    state.joint_states[6].velocity = 0.000000;
    state.joint_states[6].effort = 0.000000;
    state.joint_states[7].name = "wrist_roll_joint";
    state.joint_states[7].position = 0;
    state.joint_states[7].velocity = 0.000000;
    state.joint_states[7].effort = 0.000000;
    state.joint_states[8].name = "gripper_axis";
    state.joint_states[8].position = 0;
    state.joint_states[8].velocity = 0.000000;
    state.joint_states[8].effort = 0.000000;
    robot->set_state(state);

    auto chain = robot->get_joints_in_chain("gripper_link");
    Eigen::Affine3d ee_transform;
    Eigen::MatrixXd actual = solver.get_jacobian(chain, ee_transform);

    Eigen::MatrixXd expected =
        (Eigen::MatrixXd(6, 9) << 0, 0, 0, 0, 0, 0, 0, 0, 0, 6.12300000537636e-17, 1.09544999152422,
         -5.9910493113924e-17, 0, -3.83575332117862e-17, 0, -1.8672088446323e-17, 0, 0, 1, -6.70744030399233e-17,
         -0.978449992835522, 0, -0.62644999474287, 0, -0.304949998855591, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0,
         6.12300000537636e-17, 1, 0, 1, 0, 1, 0, 0, 0, 1, -6.12300000537636e-17, 0, -6.12300000537636e-17, 0,
         -6.12300000537636e-17, 0, 0)
            .finished();

    EXPECT_TRUE(actual.isApprox(expected, 1e-10)) << "Jacobian doesn't match expected\n"
                                                  << "Actual:\n"
                                                  << actual << "\n"
                                                  << "Expected:\n"
                                                  << expected << "\n"
                                                  << "Difference:\n"
                                                  << (actual - expected);
}

TEST(KinematicsSolver, FK_HardCoded_FETCH_Test2) {
    auto robot = std::make_shared<RobotModel>(RobotModel::from_json(FETCH_JRDF));
    KinematicsSolver solver(robot);

    JS state;
    state.joint_states.resize(9);
    state.joint_states[0].name = "torso_lift_joint";
    state.joint_states[0].position = 0.15;
    state.joint_states[0].velocity = 0.000000;
    state.joint_states[0].effort = 0.000000;
    state.joint_states[1].name = "shoulder_pan_joint";
    state.joint_states[1].position = -0.3;
    state.joint_states[1].velocity = 0.000000;
    state.joint_states[1].effort = 0.000000;
    state.joint_states[2].name = "shoulder_lift_joint";
    state.joint_states[2].position = 0.4;
    state.joint_states[2].velocity = 0.000000;
    state.joint_states[2].effort = 0.000000;
    state.joint_states[3].name = "upperarm_roll_joint";
    state.joint_states[3].position = -0.1;
    state.joint_states[3].velocity = 0.000000;
    state.joint_states[3].effort = 0.000000;
    state.joint_states[4].name = "elbow_flex_joint";
    state.joint_states[4].position = 0.8;
    state.joint_states[4].velocity = 0.000000;
    state.joint_states[4].effort = 0.000000;
    state.joint_states[5].name = "forearm_roll_joint";
    state.joint_states[5].position = -0.2;
    state.joint_states[5].velocity = 0.000000;
    state.joint_states[5].effort = 0.000000;
    state.joint_states[6].name = "wrist_flex_joint";
    state.joint_states[6].position = 0.9;
    state.joint_states[6].velocity = 0.000000;
    state.joint_states[6].effort = 0.000000;
    state.joint_states[7].name = "wrist_roll_joint";
    state.joint_states[7].position = 0.4;
    state.joint_states[7].velocity = 0.000000;
    state.joint_states[7].effort = 0.000000;
    state.joint_states[8].name = "gripper_axis";
    state.joint_states[8].position = 0;
    state.joint_states[8].velocity = 0.000000;
    state.joint_states[8].effort = 0.000000;
    robot->set_state(state);

    Transform result = solver.solve_fk("gripper_link");
    Eigen::Affine3d actual = msg_to_eigen(result);

    Eigen::Affine3d expected;
    expected.matrix() << -0.535487708784006, 0.393163638719372, 0.747445754187952, 0.395779550075531,
        -0.0989319915545011, 0.849734308563715, -0.517845589908322, -0.217113137245178, -0.838728360860484,
        -0.351246277032769, -0.416125806395124, 0.244575202465057, 0, 0, 0, 1;

    EXPECT_TRUE(actual.matrix().isApprox(expected.matrix(), 1e-10)) << "FK output doesn't match expected transform\n"
                                                                    << "Actual:\n"
                                                                    << actual.matrix() << "\n"
                                                                    << "Expected:\n"
                                                                    << expected.matrix() << "\n"
                                                                    << "Difference:\n"
                                                                    << (actual.matrix() - expected.matrix());
}

TEST(KinematicsSolver, Jacobian_HardCoded_FETCH_Test2) {
    auto robot = std::make_shared<RobotModel>(RobotModel::from_json(FETCH_JRDF));
    KinematicsSolver solver(robot);

    JS state;
    state.joint_states.resize(9);
    state.joint_states[0].name = "torso_lift_joint";
    state.joint_states[0].position = 0.15;
    state.joint_states[0].velocity = 0.000000;
    state.joint_states[0].effort = 0.000000;
    state.joint_states[1].name = "shoulder_pan_joint";
    state.joint_states[1].position = -0.3;
    state.joint_states[1].velocity = 0.000000;
    state.joint_states[1].effort = 0.000000;
    state.joint_states[2].name = "shoulder_lift_joint";
    state.joint_states[2].position = 0.4;
    state.joint_states[2].velocity = 0.000000;
    state.joint_states[2].effort = 0.000000;
    state.joint_states[3].name = "upperarm_roll_joint";
    state.joint_states[3].position = -0.1;
    state.joint_states[3].velocity = 0.000000;
    state.joint_states[3].effort = 0.000000;
    state.joint_states[4].name = "elbow_flex_joint";
    state.joint_states[4].position = 0.8;
    state.joint_states[4].velocity = 0.000000;
    state.joint_states[4].effort = 0.000000;
    state.joint_states[5].name = "forearm_roll_joint";
    state.joint_states[5].position = -0.2;
    state.joint_states[5].velocity = 0.000000;
    state.joint_states[5].effort = 0.000000;
    state.joint_states[6].name = "wrist_flex_joint";
    state.joint_states[6].position = 0.9;
    state.joint_states[6].velocity = 0.000000;
    state.joint_states[6].effort = 0.000000;
    state.joint_states[7].name = "wrist_roll_joint";
    state.joint_states[7].position = 0.4;
    state.joint_states[7].velocity = 0.000000;
    state.joint_states[7].effort = 0.000000;
    state.joint_states[8].name = "gripper_axis";
    state.joint_states[8].position = 0;
    state.joint_states[8].velocity = 0.000000;
    state.joint_states[8].effort = 0.000000;
    robot->set_state(state);

    auto chain = robot->get_joints_in_chain("gripper_link");
    Eigen::Affine3d ee_transform;
    Eigen::MatrixXd actual = solver.get_jacobian(chain, ee_transform);

    Eigen::MatrixXd expected =
        (Eigen::MatrixXd(6, 9) << 0, 0.217113136402932, -0.660552896300302, 0.117119746326431, -0.541297758445204,
         0.0169741582650666, -0.256630151272758, -7.928033248362e-18, 0, 6.12300000537636e-17, 0.363129556660328,
         0.204332949362146, 0.510527186051013, 0.14778475741784, 0.235128942576196, 0.0445425971260422,
         2.99846654756751e-18, 0, 1, -2.22344227738351e-17, -0.294072235180008, -0.0922018745875431, 0.0338823918671286,
         -0.0385717590324234, 0.158592010803208, 6.31573419837551e-18, 0, 0, 0, 0.295520198475071, 0.879923179958854,
         0.256903245852546, 0.326342861430347, 0.0710585900095639, -0.535487780042417, 0, 0, 6.12300000537636e-17,
         0.955336491874234, -0.27219212810986, 0.962052716894226, -0.175913948210707, 0.984315704432004,
         -0.0989319937049364, 0, 0, 1, -5.84952534488217e-17, -0.389418347145915, -0.0919526662794125,
         -0.928738179103549, -0.161472201747567, -0.838728391076262, 0)
            .finished();

    EXPECT_TRUE(actual.isApprox(expected, 1e-10)) << "Jacobian doesn't match expected\n"
                                                  << "Actual:\n"
                                                  << actual << "\n"
                                                  << "Expected:\n"
                                                  << expected << "\n"
                                                  << "Difference:\n"
                                                  << (actual - expected);
}

TEST(KinematicsSolver, IK_HardCoded_FETCH_Test1) {
    auto robot = std::make_shared<RobotModel>(RobotModel::from_json(FETCH_JRDF));
    KinematicsSolver solver(robot);

    Transform goal = eigen_to_msg(Eigen::Affine3d(
        (Eigen::Matrix4d() << 1, -0, 0, 1.1281, 0, 1, 6.123e-17, 2.50174e-17, -0, -6.123e-17, 1, 0.78601, 0, 0, 0, 1)
            .finished()));

    JS state;
    state.joint_states.resize(9);
    state.joint_states[0].name = "torso_lift_joint";
    state.joint_states[0].position = 0.1;
    state.joint_states[0].velocity = 0.000000;
    state.joint_states[0].effort = 0.000000;
    state.joint_states[1].name = "shoulder_pan_joint";
    state.joint_states[1].position = 0.1;
    state.joint_states[1].velocity = 0.000000;
    state.joint_states[1].effort = 0.000000;
    state.joint_states[2].name = "shoulder_lift_joint";
    state.joint_states[2].position = 0.1;
    state.joint_states[2].velocity = 0.000000;
    state.joint_states[2].effort = 0.000000;
    state.joint_states[3].name = "upperarm_roll_joint";
    state.joint_states[3].position = 0.1;
    state.joint_states[3].velocity = 0.000000;
    state.joint_states[3].effort = 0.000000;
    state.joint_states[4].name = "elbow_flex_joint";
    state.joint_states[4].position = 0.1;
    state.joint_states[4].velocity = 0.000000;
    state.joint_states[4].effort = 0.000000;
    state.joint_states[5].name = "forearm_roll_joint";
    state.joint_states[5].position = 0.1;
    state.joint_states[5].velocity = 0.000000;
    state.joint_states[5].effort = 0.000000;
    state.joint_states[6].name = "wrist_flex_joint";
    state.joint_states[6].position = 0.1;
    state.joint_states[6].velocity = 0.000000;
    state.joint_states[6].effort = 0.000000;
    state.joint_states[7].name = "wrist_roll_joint";
    state.joint_states[7].position = 0.1;
    state.joint_states[7].velocity = 0.000000;
    state.joint_states[7].effort = 0.000000;
    state.joint_states[8].name = "gripper_axis";
    state.joint_states[8].position = 0.1;
    state.joint_states[8].velocity = 0.000000;
    state.joint_states[8].effort = 0.000000;

    JS solution;
    bool converged = solver.solve_ik("gripper_link", goal, state, solution);

    EXPECT_TRUE(converged) << "IK should converge for this test case";

    if (converged) {
        robot->set_state(solution);
        Transform result = solver.solve_fk("gripper_link");
        Eigen::Affine3d result_transform = msg_to_eigen(result);
        Eigen::Affine3d goal_transform = msg_to_eigen(goal);

        Eigen::Vector3d pos_error = result_transform.translation() - goal_transform.translation();
        EXPECT_LT(pos_error.norm(), 1e-3) << "Position error too large";

        Eigen::AngleAxisd rot_error(goal_transform.rotation() * result_transform.rotation().transpose());
        EXPECT_LT(std::abs(rot_error.angle()), 1e-3) << "Orientation error too large";
    }
}

TEST(KinematicsSolver, IK_HardCoded_FETCH_Test2) {
    auto robot = std::make_shared<RobotModel>(RobotModel::from_json(FETCH_JRDF));
    KinematicsSolver solver(robot);

    Transform goal =
        eigen_to_msg(Eigen::Affine3d((Eigen::Matrix4d() << -0.535488, 0.393164, 0.747446, 0.39578, -0.098932, 0.849734,
                                      -0.517846, -0.217113, -0.838728, -0.351246, -0.416126, 0.244575, 0, 0, 0, 1)
                                         .finished()));

    JS state;
    state.joint_states.resize(9);
    state.joint_states[0].name = "torso_lift_joint";
    state.joint_states[0].position = 0.1;
    state.joint_states[0].velocity = 0.000000;
    state.joint_states[0].effort = 0.000000;
    state.joint_states[1].name = "shoulder_pan_joint";
    state.joint_states[1].position = 0.1;
    state.joint_states[1].velocity = 0.000000;
    state.joint_states[1].effort = 0.000000;
    state.joint_states[2].name = "shoulder_lift_joint";
    state.joint_states[2].position = 0.1;
    state.joint_states[2].velocity = 0.000000;
    state.joint_states[2].effort = 0.000000;
    state.joint_states[3].name = "upperarm_roll_joint";
    state.joint_states[3].position = 0.1;
    state.joint_states[3].velocity = 0.000000;
    state.joint_states[3].effort = 0.000000;
    state.joint_states[4].name = "elbow_flex_joint";
    state.joint_states[4].position = 0.1;
    state.joint_states[4].velocity = 0.000000;
    state.joint_states[4].effort = 0.000000;
    state.joint_states[5].name = "forearm_roll_joint";
    state.joint_states[5].position = 0.1;
    state.joint_states[5].velocity = 0.000000;
    state.joint_states[5].effort = 0.000000;
    state.joint_states[6].name = "wrist_flex_joint";
    state.joint_states[6].position = 0.1;
    state.joint_states[6].velocity = 0.000000;
    state.joint_states[6].effort = 0.000000;
    state.joint_states[7].name = "wrist_roll_joint";
    state.joint_states[7].position = 0.1;
    state.joint_states[7].velocity = 0.000000;
    state.joint_states[7].effort = 0.000000;
    state.joint_states[8].name = "gripper_axis";
    state.joint_states[8].position = 0.1;
    state.joint_states[8].velocity = 0.000000;
    state.joint_states[8].effort = 0.000000;

    JS solution;
    bool converged = solver.solve_ik("gripper_link", goal, state, solution);

    EXPECT_TRUE(converged) << "IK should converge for this test case";

    if (converged) {
        robot->set_state(solution);
        Transform result = solver.solve_fk("gripper_link");
        Eigen::Affine3d result_transform = msg_to_eigen(result);
        Eigen::Affine3d goal_transform = msg_to_eigen(goal);

        Eigen::Vector3d pos_error = result_transform.translation() - goal_transform.translation();
        EXPECT_LT(pos_error.norm(), 1e-3) << "Position error too large";

        Eigen::AngleAxisd rot_error(goal_transform.rotation() * result_transform.rotation().transpose());
        EXPECT_LT(std::abs(rot_error.angle()), 1e-3) << "Orientation error too large";
    }
}
